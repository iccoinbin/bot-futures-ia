import os, time, sys
import pandas as pd
import psycopg2
import psycopg2.extras as pxe
from datetime import timedelta
import traceback

DBH = os.getenv("DB_HOST","localhost")
DBP = int(os.getenv("DB_PORT","5432"))
DBN = os.getenv("DB_NAME","botfutures")
DBU = os.getenv("DB_USER","botfutures_user")
DBW = os.getenv("DB_PASSWORD","")
SYMBOLS = os.getenv("FEATURE_SYMBOLS","BTCUSDT,ETHUSDT").split(",")
TF = os.getenv("FEATURE_TIMEFRAMES","1m,5m,15m").split(",")
CANDLES_TABLE = os.getenv("CANDLES_TABLE","candles")  # esperado: ts,symbol,timeframe,open,high,low,close,volume

def connect():
    return psycopg2.connect(host=DBH, port=DBP, dbname=DBN, user=DBU, password=DBW)

def compute_features(df):
    # Regras simples/robustas sem order_flow:
    # ema_slope_20: variação da EMA20 nos últimos 20 períodos
    # vwap_slope_20: variação do VWAP20
    # adx/atr: proxys simplificados para manter robustez (sem TA libs)
    # std_20: desvio padrão 20
    if df.empty: return df
    df = df.sort_values("ts")
    # EMA20 manual simples
    ema = df["close"].ewm(span=20, adjust=False).mean()
    df["ema_slope_20"] = ema.diff(20)
    # VWAP20
    pv = (df["close"]*df["volume"]).rolling(20, min_periods=1).sum()
    vv = df["volume"].rolling(20, min_periods=1).sum().replace(0, 1e-12)
    vwap20 = pv / vv
    df["vwap_slope_20"] = vwap20.diff(20)
    # Proxy ADX14 (simplificada): média do |ret|*100
    ret = df["close"].pct_change().abs()
    df["adx_14"] = (ret.rolling(14, min_periods=1).mean()*100.0)
    # ATR14 aproximado (HL range com suavização)
    tr = (df["high"]-df["low"]).abs()
    df["atr_14"] = tr.rolling(14, min_periods=1).mean()
    # STD20
    df["std_20"] = df["close"].rolling(20, min_periods=1).std()
    # Regime simples
    def regime_row(s):
        if s > 0: return "bull"
        if s < 0: return "bear"
        return "sideways"
    df["regime"] = df["ema_slope_20"].fillna(0).apply(regime_row)
    return df

def upsert_features(cur, rows):
    if not rows: return
    pxe.execute_values(
        cur,
        """
        INSERT INTO public.features
        (ts, symbol, timeframe, ema_slope_20, vwap_slope_20, adx_14, atr_14, std_20, regime)
        VALUES %s
        ON CONFLICT (ts, symbol, timeframe) DO UPDATE SET
          ema_slope_20 = EXCLUDED.ema_slope_20,
          vwap_slope_20 = EXCLUDED.vwap_slope_20,
          adx_14       = EXCLUDED.adx_14,
          atr_14       = EXCLUDED.atr_14,
          std_20       = EXCLUDED.std_20,
          regime       = EXCLUDED.regime;
        """,
        rows, page_size=500
    )

def fetch_candles(conn, symbol, timeframe, lookback=400):
    with conn.cursor(cursor_factory=pxe.DictCursor) as c:
        c.execute(f"""
            SELECT ts, symbol, timeframe, open, high, low, close, volume
            FROM {CANDLES_TABLE}
            WHERE symbol = %s AND timeframe = %s
            ORDER BY ts DESC
            LIMIT %s;
        """, (symbol, timeframe, lookback))
        rows = c.fetchall()
    if not rows: return pd.DataFrame()
    df = pd.DataFrame(rows)
    return df

def main_loop():
    poll_secs = int(os.getenv("FEATURE_POLL_SECONDS","30"))
    while True:
        try:
            with connect() as conn:
                with conn.cursor() as cur:
                    total = 0
                    for sym in SYMBOLS:
            for tf in TF:
                try:
                    df = fetch_candles(conn, sym, tf)
                    if df.empty:
                        _log(f"skip empty sym={sym} tf={tf}")
                        continue
                    if 'ts' not in df.columns:
                        _log(f"MISSING_TS cols={list(df.columns)} size={len(df)} sym={sym} tf={tf}")
                        continue
                    feat = compute_features(df).tail(1)
                    if feat is None or feat.empty:
                        _log(f"computed=EMPTY sym={sym} tf={tf}")
                        continue
                    rows = [
                        (
                            row["ts"], row["symbol"], row["timeframe"],
                            float(row.get("ema_slope_20", 0) or 0),
                            float(row.get("vwap_slope_20", 0) or 0),
                            float(row.get("adx_14", 0) or 0),
                            float(row.get("atr_14", 0) or 0),
                            float(row.get("std_20", 0) or 0),
                            str(row.get("regime") or "sideways"),
                        )
                        for _, row in feat.iterrows()
                    ]
                    with conn:
                        with conn.cursor() as c2:
                            upsert_features(c2, rows)
                    total += len(rows)
                    _log(f"upserted={len(rows)} sym={sym} tf={tf}")
                except Exception as ex:
                    _log(f"EXC sym={sym} tf={tf} err={type(ex).__name__}: {ex}")
                    import traceback; traceback.print_exc()
            # feedback mínimo no stdout (capturado pelo journal)
            print(f"[feature_engine_v1] upsert={total}")(f"[feature_engine_v1] upsert={total}")
        except Exception as e:
            print(f"[feature_engine_v1][ERROR] {e}", file=sys.stderr)
        time.sleep(poll_secs)

if __name__ == "__main__":
    main_loop()


def _log(msg):
    try:
        print(f"[feature_engine_v1][DIAG] {msg}", flush=True)
    except Exception:
        pass
